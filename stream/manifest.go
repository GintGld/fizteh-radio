/*
 * MPD manifests API
 * ffmepg.go is used to wrap calls to FFmpeg
 * "github.com/zencoder/go-dash/v3/mpd" is used to easily manage manifests
 *
 * Gintaras Gliaudelis 09.11.2023
 */

package stream

import (
	"fmt"
	"time"

	"github.com/zencoder/go-dash/v3/mpd"
)

// Dynamic manifest for streaming
// Been initialized in func initMPD
var manifest *mpd.MPD

// Equals (start + duration) for the last period
// in the dynamic manifest (= 0 if there are no periods).
// Useful for adding new periods
var lastTimeStamp mpd.Duration

// Create dynamic manifest
func initMPD() {
	lastTimeStamp = 0

	manifest = mpd.NewDynamicMPD(
		mpd.DASH_PROFILE_LIVE,
		ScheduleGlobalConfig.AvailabilityStartTime.String(),
		ScheduleGlobalConfig.MinBufferTime,
		mpd.AttrPublishTime(ScheduleGlobalConfig.AvailabilityStartTime.String()),
		mpd.AttrMinimumUpdatePeriod(ScheduleGlobalConfig.MinimumUpdatePeriod),
	)
}

// Add new compisition to dynamic manifest
func AddNewComposition(cmp *composition) error {
	// Generate DASH files
	err := generateDASHFiles(cmp)
	if err != nil {
		return err
	}

	// Get manifest generated by ffmpeg during file splitting
	tmpMPD, err := mpd.ReadFromFile(mpdFile(cmp))
	if err != nil {
		return err
	}

	// Check if there is only one period as expected
	if len(tmpMPD.Periods) == 0 {
		return fmt.Errorf("didn't find any periods in MPD manifest %s", mpdFile(cmp))
	} else if len(tmpMPD.Periods) > 1 {
		return fmt.Errorf("expected 1 period in MPD manifest %s, got %d", mpdFile(cmp), len(tmpMPD.Periods))
	}

	// Get this period
	period := tmpMPD.Periods[0]

	// Set `start` and `duration`
	// correctly for dynamic manifest
	*period.Start = lastTimeStamp
	period.Duration = mpd.Duration(cmp.meta.duration)

	// update `lastTimeStep`
	lastTimeStamp += period.Duration

	// Append new period to dynamic manifest
	manifest.Periods = append(manifest.Periods, period)

	return nil
}

// TODO: delete DASH files
// Delete periods that have played already
// to optimize dynamic manifest size
func DeleteAlreadyPlayed() error {
	if len(manifest.Periods) == 0 {
		return nil
	}

	// Fix time moment
	currentTime := time.Now().Unix()
	start := ScheduleGlobalConfig.AvailabilityStartTime

	// Iterate over all periods
	for i := 0; i < len(manifest.Periods); i++ {
		// If period is playing now, all
		// periods before it will be deleted
		if start.Unix() <= currentTime && currentTime <= start.Add(time.Duration(manifest.Periods[i].Duration)).Unix() {
			manifest.Periods = manifest.Periods[i-1:]
			return nil
		}
		start = start.Add(time.Duration(manifest.Periods[i].Duration))
	}

	// All manifest was played case
	clear(manifest.Periods)

	return fmt.Errorf("manifest does not have actual content. time %s", time.Unix(currentTime, 0).String())
}

// Save actual version of dynamic manifest
func writeDynamicManifest() error {
	return manifest.WriteToFile(ScheduleGlobalConfig.SchedulePath)
}
