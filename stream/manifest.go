/*
 * MPD manifests API
 * ffmepg.go is used to wrap calls to FFmpeg
 * "github.com/zencoder/go-dash/v3/mpd" is used to easily manage manifests
 *
 * Gintaras Gliaudelis 09.11.2023
 */

package stream

import (
	"fmt"
	"strconv"
	"time"

	"github.com/zencoder/go-dash/v3/mpd"
)

// Dynamic manifest for streaming
// Been initialized in func initMPD
var manifest *mpd.MPD

// Equals (start + duration) for the last period
// in the dynamic manifest (= 0 if there are no periods).
// Useful for adding new periods
var lastTimeStamp mpd.Duration

// Last PeriodID used in streadynamic manifest
var lastPeriodID int

// Cache for playing compositions.
// Key    - period ID (string because mpd.period.ID is string)
// Values - pointer for corresponding composition.
// Used in deleting ffmpeg generated files
var compositionCache map[string]*composition

// Create dynamic manifest
func initMPD() {
	lastTimeStamp = 0
	lastPeriodID = 0

	manifest = mpd.NewDynamicMPD(
		mpd.DASH_PROFILE_LIVE,
		ScheduleGlobalConfig.AvailabilityStartTime.String(),
		ScheduleGlobalConfig.MinBufferTime,
		mpd.AttrPublishTime(ScheduleGlobalConfig.AvailabilityStartTime.String()),
		mpd.AttrMinimumUpdatePeriod(ScheduleGlobalConfig.MinimumUpdatePeriod),
	)
}

// Add new compisition to dynamic manifest
func addNewComposition(cmp *composition) error {
	// Generate DASH files
	err := generateDASHFiles(cmp)
	if err != nil {
		return err
	}

	// Get manifest generated by ffmpeg during file splitting
	tmpMPD, err := mpd.ReadFromFile(cmp.mpdFile())
	if err != nil {
		return err
	}

	// Check if there is only one period as expected
	if len(tmpMPD.Periods) == 0 {
		return fmt.Errorf("didn't find any periods in MPD manifest %s", cmp.mpdFile())
	} else if len(tmpMPD.Periods) > 1 {
		return fmt.Errorf("expected 1 period in MPD manifest %s, got %d", cmp.mpdFile(), len(tmpMPD.Periods))
	}

	// Get this period
	period := tmpMPD.Periods[0]

	// Set `start` and `duration`
	// correctly for dynamic manifest
	*period.Start = lastTimeStamp
	period.Duration = mpd.Duration(cmp.meta.duration)
	lastTimeStamp += period.Duration

	// Set id for period
	lastPeriodID++
	period.ID = strconv.Itoa(lastPeriodID)

	// Cache composition to delete it correctly in the future
	compositionCache[period.ID] = cmp

	// Add new period to dynamic manifest
	manifest.Periods = append(manifest.Periods, period)

	return nil
}

// Delete periods that have played already
// to optimize dynamic manifest size
func deleteAlreadyPlayed() error {
	if len(manifest.Periods) == 0 {
		return nil
	}

	// Fix time moment
	currentTime := time.Now().Unix()
	start := ScheduleGlobalConfig.AvailabilityStartTime

	// Iterate over all periods
	for i := 0; i < len(manifest.Periods); i++ {
		// If period is playing now, all
		// periods before it will be deleted
		if start.Unix() <= currentTime && currentTime <= start.Add(time.Duration(manifest.Periods[i].Duration)).Unix() {
			// delete already played segments
			for _, p := range manifest.Periods[:i-1] {
				// delete segments
				err := deleteDASHFiles(compositionCache[p.ID])
				if err != nil {
					return nil
				}
				// optimize cache
				delete(compositionCache, p.ID)
			}

			// delete periods from dynamic manifest
			manifest.Periods = manifest.Periods[i-1:]

			return nil
		}
		start = start.Add(time.Duration(manifest.Periods[i].Duration))
	}

	// All manifest were played case
	for _, p := range manifest.Periods {
		deleteDASHFiles(compositionCache[p.ID])
		delete(compositionCache, p.ID)
	}
	clear(manifest.Periods)

	return fmt.Errorf("manifest does not have actual content. time %s", time.Unix(currentTime, 0).String())
}

// Save actual version of dynamic manifest
func writeDynamicManifest() error {
	return manifest.WriteToFile(ScheduleGlobalConfig.SchedulePath)
}
