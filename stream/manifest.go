/*
 * MPD manifests API
 * ffmepg.go is used to wrap calls to FFmpeg
 * "github.com/zencoder/go-dash/v3/mpd" is used to easily manage manifests
 *
 * Gintaras Gliaudelis 09.11.2023
 */

package stream

import (
	"fmt"
	"strconv"
	"time"

	"github.com/zencoder/go-dash/v3/mpd"
)

// manifestAPI.
//
// man (manifest).
// Dynamic manifest for streaming.
// Been initialized in func initMPD.
//
// lastTimeStep.
// Equals (start + duration) for the last period.
// in the dynamic manifest (= 0 if there are no periods).
// Useful for adding new periods.
//
// lastPeriodID.
// Used in streadynamic manifest.
//
// compositionCache.
// Key    - period ID (string because mpd.period.ID is string).
// Values - pointer for corresponding composition.
// Used in deleting ffmpeg generated files.
type manifestAPI struct {
	man *mpd.MPD

	lastTimeStamp    mpd.Duration
	lastPeriodID     int
	compositionCache map[string]*composition
}

// Create new dynamic manifest
func (bcg *broadcastGrid) initMPD() {
	bcg.mpd.lastTimeStamp = 0
	bcg.mpd.lastPeriodID = 0

	bcg.mpd.man = mpd.NewDynamicMPD(
		mpd.DASH_PROFILE_LIVE,
		bcg.Manifest.StartTime.String(),
		bcg.Manifest.BufferTime.String(),
		mpd.AttrMinimumUpdatePeriod(bcg.Manifest.UpdateFrequency.String()),
	)
}

// Add new compisition to dynamic manifest
func (bcg *broadcastGrid) addNewComposition(cmp *composition) error {
	// Generate DASH files
	err := cmp.generateDASHFiles()
	if err != nil {
		return err
	}

	// Get manifest generated by ffmpeg during file splitting
	tmpMPD, err := mpd.ReadFromFile(cmp.mpdFile())
	if err != nil {
		return err
	}

	// Check if there is only one period as expected
	if len(tmpMPD.Periods) == 0 {
		return fmt.Errorf("didn't find any periods in MPD manifest %s", cmp.mpdFile())
	} else if len(tmpMPD.Periods) > 1 {
		return fmt.Errorf("expected 1 period in MPD manifest %s, got %d", cmp.mpdFile(), len(tmpMPD.Periods))
	}

	// Get this period
	period := tmpMPD.Periods[0]

	// Set `start` and `duration`
	// correctly for dynamic manifest
	*period.Start = bcg.mpd.lastTimeStamp
	period.Duration = mpd.Duration(cmp.meta.duration)
	bcg.mpd.lastTimeStamp += period.Duration

	// Set id for period
	bcg.mpd.lastPeriodID++
	period.ID = strconv.Itoa(bcg.mpd.lastPeriodID)

	// Cache composition to delete it correctly in the future
	bcg.mpd.compositionCache[period.ID] = cmp

	// Add new period to dynamic manifest
	bcg.mpd.man.Periods = append(bcg.mpd.man.Periods, period)

	return nil
}

// Delete periods that have played already
// to optimize dynamic manifest size
func (bcg *broadcastGrid) deleteAlreadyPlayed() error {
	if len(bcg.mpd.man.Periods) == 0 {
		return nil
	}

	// Fix time moment
	currentTime := time.Now().Unix()
	start := bcg.Manifest.StartTime

	// Iterate over all periods
	for i := 0; i < len(bcg.mpd.man.Periods); i++ {
		// If period is playing now, all
		// periods before it will be deleted
		if start.Unix() <= currentTime && currentTime <= start.Add(time.Duration(bcg.mpd.man.Periods[i].Duration)).Unix() {
			// delete already played segments
			for _, p := range bcg.mpd.man.Periods[:i-1] {
				// delete segment
				if err := bcg.mpd.compositionCache[p.ID].deleteDASHFiles(); err != nil {
					return err
				}
				// delete point from cache
				delete(bcg.mpd.compositionCache, p.ID)
			}

			// delete periods from dynamic manifest
			bcg.mpd.man.Periods = bcg.mpd.man.Periods[i-1:]

			return nil
		}
		start = start.Add(time.Duration(bcg.mpd.man.Periods[i].Duration))
	}

	// All manifest were played case
	for _, p := range bcg.mpd.man.Periods {
		bcg.mpd.compositionCache[p.ID].deleteDASHFiles()
		delete(bcg.mpd.compositionCache, p.ID)
	}
	clear(bcg.mpd.man.Periods)

	return nil
}

// Save actual version of dynamic manifest
func (bcg *broadcastGrid) dump() error {
	return bcg.mpd.man.WriteToFile(bcg.Manifest.Path)
}
