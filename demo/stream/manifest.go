/*
 * MPD manifests API
 * ffmepg.go is used to wrap calls to FFmpeg
 * "github.com/zencoder/go-dash/v3/mpd" is used to easily manage manifests
 *
 * Gintaras Gliaudelis 09.11.2023
 */

package stream

import (
	"fmt"
	"strconv"
	"time"

	"github.com/zencoder/go-dash/v3/mpd"
)

// manifestAPI.
//
// man (manifest).
// Dynamic manifest for streaming.
// Been initialized in func initMPD.
//
// lastTimeStep.
// Equals (start + duration) for the last period
// in the dynamic manifest (= 0 if there are no periods).
// Useful for adding new periods.
//
// lastPeriodID.
// Counter for periods in dynamic manifest
//
// compositionCache.
// Key    - period ID (string because mpd.period.ID is string).
// Values - pointer for corresponding composition.
// Used in deleting ffmpeg generated files.
type manifestAPI struct {
	man *mpd.MPD

	lastTimeStamp      mpd.Duration
	lastPeriodID       int
	compositionCache   map[string]*composition
	compositionCounter map[int]int
}

// Create new dynamic manifest
func (bcg *broadcastGrid) initMPD() {
	bcg.mpd.lastTimeStamp = 0
	bcg.mpd.lastPeriodID = 0

	bcg.mpd.compositionCache = make(map[string]*composition)
	bcg.mpd.compositionCounter = make(map[int]int)

	// Method (*mpd.Duration).String() takes pointer as an argument
	bufferTime := mpd.Duration(bcg.Manifest.BufferTime)
	minimumUpdatePeriod := mpd.Duration(bcg.Manifest.UpdateFrequency)

	bcg.mpd.man = mpd.NewDynamicMPD(
		mpd.DASH_PROFILE_LIVE,
		bcg.Manifest.StartTime.UTC().Format("2006-01-02T15:04:05"), // see https://ffmpeg.org/doxygen/trunk/dashdec_8c_source.html get_utc_date_time_insec
		bufferTime.String(),
		mpd.AttrMinimumUpdatePeriod(minimumUpdatePeriod.String()),
	)

	BufferDepth := "PT5S"

	bcg.mpd.man.TimeShiftBufferDepth = &BufferDepth

	UTCTimingSchemeIDURI := "urn:mpeg:dash:utc:http-iso:2014"
	UTCTimingValue := "https://time.akamai.com/?isoms"

	// Set UTCTiming for client synchronisation
	bcg.mpd.man.UTCTiming.SchemeIDURI = &UTCTimingSchemeIDURI
	bcg.mpd.man.UTCTiming.Value = &UTCTimingValue

	// *bcg.mpd.man.Profiles = "urn:mpeg:dash:profile:isoff-live:2011,http://dashif.org/guidelines/dash-if-simple"

	// *bcg.mpd.man.UTCTiming.SchemeIDURI = "urn:mpeg:dash:utc:http-head:2014"
	// *bcg.mpd.man.UTCTiming.Value = "http://time.akamai.com/?iso"

	// Reset array of periods,because it has
	// uneccecary for our realisation element
	bcg.mpd.man.Periods = nil
}

// Add new compisition to dynamic manifest
func (bcg *broadcastGrid) addNewComposition(cmp *composition) error {
	// Generate DASH files
	err := cmp.generateDASHFiles()
	if err != nil {
		return err
	}

	// Get manifest generated by ffmpeg during file splitting
	tmpMPD, err := mpd.ReadFromFile(cmp.mpdFile())
	if err != nil {
		return err
	}

	// Check if there is only one period as expected
	if len(tmpMPD.Periods) == 0 {
		return fmt.Errorf("didn't find any periods in MPD manifest %s", cmp.mpdFile())
	} else if len(tmpMPD.Periods) > 1 {
		return fmt.Errorf("expected 1 period in MPD manifest %s, got %d", cmp.mpdFile(), len(tmpMPD.Periods))
	}

	// Get this period
	period := tmpMPD.Periods[0]

	// Set `start` and `duration`
	// correctly for dynamic manifest
	*period.Start = bcg.mpd.lastTimeStamp
	period.Duration = mpd.Duration(cmp.meta.duration)
	bcg.mpd.lastTimeStamp += period.Duration

	// Set id for period
	period.ID = strconv.Itoa(bcg.mpd.lastPeriodID)
	*period.AdaptationSets[0].ID = strconv.Itoa(bcg.mpd.lastPeriodID)
	// *period.AdaptationSets[0].Representations[0].ID = strconv.Itoa(bcg.mpd.lastPeriodID)
	bcg.mpd.lastPeriodID++

	// Cache composition to delete it correctly in the future
	bcg.mpd.compositionCache[period.ID] = cmp

	// Add new period to dynamic manifest
	bcg.mpd.man.Periods = append(bcg.mpd.man.Periods, period)

	if _, exist := bcg.mpd.compositionCounter[cmp.id]; !exist {
		bcg.mpd.compositionCounter[cmp.id] = 1
	} else {
		bcg.mpd.compositionCounter[cmp.id]++
	}

	return nil
}

// Delete periods that have played already
// to optimize dynamic manifest size
func (bcg *broadcastGrid) deleteAlreadyPlayed() error {
	if len(bcg.mpd.man.Periods) == 0 {
		return nil
	}

	// Fix time moment
	currentTime := time.Now()

	// Iterate over all periods
	// start form 2, because manifest always has nil-period at the start
	for i := 0; i < len(bcg.mpd.man.Periods); i++ {
		// start and the end of the composition in absolute time
		start := bcg.Manifest.StartTime.Add(time.Duration(*bcg.mpd.man.Periods[i].Start))
		end := start.Add(time.Duration(bcg.mpd.man.Periods[i].Duration))

		// If period is playing now, all
		// periods before it will be deleted
		if currentTime.After(start) && currentTime.Before(end) {
			// First period is playing case, nothing to delete
			if i == 0 {
				return nil
			}

			// Delete already played segments
			for _, p := range bcg.mpd.man.Periods[:i] {

				cmp := bcg.mpd.compositionCache[p.ID]
				bcg.mpd.compositionCounter[cmp.id]--
				// Delete segment
				if bcg.mpd.compositionCounter[cmp.id] == 0 {
					if err := cmp.deleteDASHFiles(); err != nil {
						return err
					}
					delete(bcg.mpd.compositionCounter, cmp.id)
				}

				// Delete point from cache
				delete(bcg.mpd.compositionCache, p.ID)

			}

			// Delete periods from dynamic manifest
			bcg.mpd.man.Periods = bcg.mpd.man.Periods[i:]

			return nil
		}
	}

	// All manifest were played case,
	// It is unwanted behavior, so error returned
	for _, p := range bcg.mpd.man.Periods {
		cmp := bcg.mpd.compositionCache[p.ID]
		bcg.mpd.compositionCounter[cmp.id]--
		// delete segment
		if bcg.mpd.compositionCounter[cmp.id] == 0 {
			if err := cmp.deleteDASHFiles(); err != nil {
				return err
			}
			delete(bcg.mpd.compositionCounter, cmp.id)
		}
		delete(bcg.mpd.compositionCache, p.ID)
	}
	clear(bcg.mpd.man.Periods)

	return fmt.Errorf("have get out of the time schedule. Time: %s", currentTime.String())
}

// Save actual version of dynamic manifest
func (bcg *broadcastGrid) dump() error {
	return bcg.mpd.man.WriteToFile(bcg.Manifest.Path)
}
