package service

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"strconv"
	"time"

	"github.com/GintGld/fizteh-radio/internal/lib/ffmpeg"
	"github.com/GintGld/fizteh-radio/internal/lib/logger/sl"
	"github.com/GintGld/fizteh-radio/internal/lib/utils/writer"
	"github.com/GintGld/fizteh-radio/internal/models"
)

// TODO: move waitBeforeDelete to config

const (
	maxBitrate       = 96000
	maxSamplingRate  = 44100
	mpdFile          = "tmp.mpd" // ffmpeg needs to have file to dump manifest for splitted composition
	waitBeforeDelete = 15 * time.Second
)

// Generate segments
func (c *Content) generateDASHFiles(ctx context.Context, s models.Segment) error {
	const op = "Content.generateDASHFiles"

	log := c.log.With(
		slog.String("op", op),
	)

	// target path
	path := c.path + "/" + ffmpeg.Dir(*s.ID)

	// check if content already exists
	if fileInfo, err := os.Stat(path); err == nil {
		if !fileInfo.IsDir() {
			log.Error(
				"is not directory",
				slog.String("path", path),
			)
			return fmt.Errorf("%s: is not directory", op)
		}
		return nil
	} else if !errors.Is(err, os.ErrNotExist) {
		log.Error(
			"failed to get path stat",
			slog.String("path", path),
			sl.Err(err),
		)
		return fmt.Errorf("%s: %w", op, err)
	}

	if err := os.MkdirAll(path, 0777); err != nil {
		log.Error(
			"failed to make dir",
			slog.String("dir", path),
			sl.Err(err),
		)
		return err
	}

	media, err := c.media.Media(ctx, *s.MediaID)
	if err != nil {
		log.Error(
			"failed to get media",
			slog.Int64("mediaID", *s.MediaID),
			sl.Err(err),
		)
		return fmt.Errorf("%s: %w", op, err)
	}

	filePath, err := c.source.LoadSource(ctx, c.path+"/.cache", media)
	if err != nil {
		log.Error(
			"failed to load source file",
			slog.Int64("sourceID", *media.SourceID),
			sl.Err(err),
		)
		return fmt.Errorf("%s: %w", op, err)
	}

	// TODO: get meta information
	// TODO: or move stream parameters to config

	// set the limit for bitrate (placeholder before bitrateSwitching)
	bitrate := maxBitrate
	// if cmp.meta.bitrate < bitrate {
	// 	bitrate = cmp.meta.bitrate
	// }
	// set the limit for sampling rate
	samplingRate := maxSamplingRate
	// if cmp.meta.sampling_rate < samplingRate {
	// 	samplingRate = cmp.meta.sampling_rate
	// }

	startString := strconv.FormatFloat(s.BeginCut.Seconds(), 'g', -1, 64)
	stopString := strconv.FormatFloat(s.StopCut.Seconds(), 'g', -1, 64)
	durationString := strconv.FormatFloat(c.chunkLength.Seconds(), 'g', -1, 64)

	cmd := exec.Command(
		"ffmpeg",           //							call converter
		"-hide_banner",     //							hide banner
		"-y",               //							force rewriting file
		"-ss", startString, //							start cut
		"-to", stopString, //							stop cut
		"-i", filePath, //								input file
		"-c:a", "aac", //								choose codec
		"-b:a", strconv.Itoa(bitrate), //				choose bitrate (TODO: make different bitrate to enable bitrateSwitching)
		"-ac", strconv.Itoa(2), //						number of channels (1 - mono, 2 - stereo)
		"-ar", strconv.Itoa(samplingRate), // 			sampling frequency (usually 44100/48000)
		"-dash_segment_type", "mp4", //					container segments format
		"-use_template", "1", //						use template instead of enumerate (shorter output)
		"-use_timeline", "0", //						disable more information about timing for all segments
		"-init_seg_name", ffmpeg.InitFile(*s.ID), //	template for initialization segment
		"-media_seg_name", ffmpeg.ChunkFile(*s.ID), //	template for data segments
		"-seg_duration", durationString, //				duration of each segment
		"-f", "dash", //								choose dash format
		c.path+"/"+mpdFile, //							output file
	)

	errorWriter := writer.New()
	cmd.Stderr = errorWriter

	if err := cmd.Run(); err != nil {
		log.Error(
			"failed to run command",
			slog.String("cmd", cmd.String()),
			slog.String("stderr", errorWriter.String()),
			sl.Err(err),
		)
		return fmt.Errorf("%s: %w", op, err)
	}

	time.AfterFunc(
		time.Until(*s.Start)+*s.StopCut-*s.BeginCut+waitBeforeDelete,
		func() { c.deleteDASHFiles(s) },
	)

	return nil
}

// Delete segments, generated by ffmpeg
// for current composition
func (c *Content) deleteDASHFiles(s models.Segment) error {
	const op = "Content.deleteDASHFiles"

	log := c.log.With(
		slog.String("op", op),
	)

	path := c.path + "/" + ffmpeg.Dir(*s.ID)
	if err := os.RemoveAll(path); err != nil {
		log.Error("failed to delete dash files", slog.String("path", path), sl.Err(err))
		return err
	}

	return nil
}

// deleteCache deletes all files in .cache
func (c *Content) deleteCache() error {
	const op = "Content.deleteCache"

	log := c.log.With(
		slog.String("op", op),
	)

	cacheDir := c.path + "/.cache"

	files, err := os.ReadDir(cacheDir)
	if err != nil {
		log.Error(
			"failed to get list of content dir",
			slog.String("dir", c.path),
			sl.Err(err),
		)
	}

	errAll := make([]error, 0)
	for _, file := range files {
		err = os.Remove(cacheDir + "/" + file.Name())
		log.Debug("delete", slog.String("file", cacheDir+"/"+file.Name()))
		if err != nil {
			log.Error(
				"failed to delete",
				slog.String("item", file.Name()),
				slog.String("cache dir", cacheDir),
				sl.Err(err),
			)
			errAll = append(errAll, err)
		}
	}
	if len(errAll) > 0 {
		return errors.Join(errAll...)
	}

	return nil
}

// deleteAll deletes all files from working directory
func (c *Content) deleteAll() error {
	const op = "Content.deleteAll"

	log := c.log.With(
		slog.String("op", op),
	)

	files, err := os.ReadDir(c.path)
	if err != nil {
		log.Error(
			"failed to get list of content dir",
			slog.String("dir", c.path),
			sl.Err(err),
		)
	}

	errAll := make([]error, 0)
	for _, file := range files {
		if file.Name() != ".cache" {
			err = os.RemoveAll(c.path + "/" + file.Name())
			if err != nil {
				log.Error(
					"failed to delete",
					slog.String("item", file.Name()),
					slog.String("dir", c.path),
					sl.Err(err),
				)
				errAll = append(errAll, err)
			}
		}
	}
	if len(errAll) > 0 {
		return errors.Join(errAll...)
	}

	if err := c.deleteCache(); err != nil {
		log.Error(
			"failed to delete cache",
			sl.Err(err),
		)
	}

	return nil
}
