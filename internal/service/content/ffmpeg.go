package service

import (
	"context"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"strconv"

	"github.com/GintGld/fizteh-radio/internal/lib/ffmpeg"
	"github.com/GintGld/fizteh-radio/internal/lib/logger/sl"
	"github.com/GintGld/fizteh-radio/internal/models"
)

const (
	maxBitrate      = 96000
	maxSamplingRate = 44100
	mpdFile         = "tmp.mpd" // ffmpeg needs to have file to dump manifest for splitted composition (TODO: check it)
)

// Generate segments
func (c *Content) generateDASHFiles(ctx context.Context, s *models.Segment) error {
	const op = "Content.generateDASHFiles"

	log := c.log.With(
		slog.String("op", op),
	)

	media, err := c.media.Media(ctx, *s.MediaID)
	if err != nil {
		log.Error(
			"failed to get media",
			slog.Int64("mediaID", *s.MediaID),
			sl.Err(err),
		)
		return fmt.Errorf("%s: %w", op, err)
	}

	log.Debug("got media", slog.Int64("mediaID", *s.MediaID))

	filePath, err := c.source.LoadSource(ctx, c.path, media)
	if err != nil {
		log.Error(
			"failed to load source file",
			slog.Int64("sourceID", *media.SourceID),
			sl.Err(err),
		)
		return fmt.Errorf("%s: %w", op, err)
	}

	log.Debug("loaded source", slog.Int64("sourceID", *media.SourceID))

	// if dir is already exist it is not an error
	if err := os.MkdirAll(c.path+"/"+ffmpeg.Dir(s), 0777); err != nil && !os.IsExist(err) {
		log.Error(
			"failed to make dir",
			slog.String("dir", c.path+"/"+ffmpeg.Dir(s)),
			sl.Err(err),
		)
		return err
	}

	log.Debug(
		"made dir",
		slog.String("dir", c.path+"/"+ffmpeg.Dir(s)),
	)

	// TODO: get meta information

	// set the limit for bitrate (placeholder before bitrateSwitching)
	bitrate := maxBitrate
	// if cmp.meta.bitrate < bitrate {
	// 	bitrate = cmp.meta.bitrate
	// }
	// set the limit for sampling rate
	samplingRate := maxSamplingRate
	// if cmp.meta.sampling_rate < samplingRate {
	// 	samplingRate = cmp.meta.sampling_rate
	// }

	startString := strconv.FormatFloat(s.BeginCut.Seconds(), 'g', -1, 64)
	stopString := strconv.FormatFloat(s.StopCut.Seconds(), 'g', -1, 64)
	durationString := strconv.FormatFloat(c.chunkLenght.Seconds(), 'g', -1, 64)

	cmd := exec.Command(
		"ffmpeg",           //						call converter
		"-hide_banner",     //						hide banner
		"-y",               //						force rewriting file
		"-ss", startString, //						start cut
		"-to", stopString, //						stop cut
		"-i", filePath, //							input file
		"-c:a", "aac", //							choose codec
		"-b:a", strconv.Itoa(bitrate), //			choose bitrate (TODO: make different bitrate to enable bitrateSwitching)
		"-ac", strconv.Itoa(2), //					number of channels (1 - mono, 2 - stereo)
		"-ar", strconv.Itoa(samplingRate), // 		sampling frequency (usually 44100/48000)
		"-dash_segment_type", "mp4", //				container segments format
		"-use_template", "1", //					use template instead of enumerate (shorter output)
		"-use_timeline", "0", //					more information about timing for all segments
		"-init_seg_name", ffmpeg.InitFile(s), //	template for initialization segment
		"-media_seg_name", ffmpeg.ChunkFile(s), //	template for data segments
		"-seg_duration", durationString, //			duration of each segment
		"-f", "dash", //							choose dash format
		c.path+"/"+mpdFile, //						output file
	)

	log.Debug("prepared cmd", slog.String("cmd", cmd.String()))

	// cmd.Stdout = os.Stdout
	// cmd.Stderr = os.Stderr

	if err := cmd.Run(); err != nil {
		log.Error(
			"failed to run cmd",
			slog.String("cmd", cmd.String()),
			sl.Err(err),
		)
		return err
	}

	return nil
}

// Delete segments and temporary manifest, generated by ffmpeg
// for current composition
func (c *Content) deleteDASHFiles(s *models.Segment) error {
	const op = "Content.deleteDASHFiles"

	log := c.log.With(
		slog.String("op", op),
	)

	path := c.path + "/" + ffmpeg.Dir(s)
	if err := os.RemoveAll(path); err != nil {
		log.Error("failed to delete dash files", slog.String("path", path), sl.Err(err))
		return err
	}
	return nil
}

// deleteAll deletes all files from working directory
func (c *Content) deleteAll() error {
	const op = "Content.deleteAll"

	log := c.log.With(
		slog.String("op", op),
	)

	cmd := exec.Command("rm", "-rf", c.path+"/*")

	if err := cmd.Run(); err != nil {
		log.Error("failed to delete "+c.path+"/*", sl.Err(err))
	}
	return nil
}
