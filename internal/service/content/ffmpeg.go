package service

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"os"
	"os/exec"
	"strconv"
	"time"

	"github.com/GintGld/fizteh-radio/internal/lib/ffmpeg"
	"github.com/GintGld/fizteh-radio/internal/lib/logger/sl"
	"github.com/GintGld/fizteh-radio/internal/models"
)

// TODO: move waitBeforeDelete to config

const (
	maxBitrate       = 96000
	maxSamplingRate  = 44100
	mpdFile          = "tmp.mpd" // ffmpeg needs to have file to dump manifest for splitted composition (TODO: check it)
	waitBeforeDelete = 15 * time.Second
)

type byteWriter struct {
	data []byte
}

func NewWriter() *byteWriter {
	return &byteWriter{
		data: make([]byte, 0),
	}
}

func (b *byteWriter) Write(data []byte) (int, error) {
	b.data = append(b.data, data...)
	return len(data), nil
}

func (b *byteWriter) String() string {
	return string(b.data)
}

// Generate segments
func (c *Content) generateDASHFiles(ctx context.Context, s models.Segment) error {
	const op = "Content.generateDASHFiles"

	log := c.log.With(
		slog.String("op", op),
	)

	// target path
	path := c.path + "/" + ffmpeg.Dir(s)

	// check if content is already exists
	if fileInfo, err := os.Stat(path); err == nil {
		if fileInfo.IsDir() == false {
			log.Error(
				"is not directory",
				slog.String("path", path),
			)
			return fmt.Errorf("%s: is not directory", op)
		}
		log.Debug(
			"content already exists",
			slog.Int64("id", *s.ID),
		)
		return nil
	} else if !errors.Is(err, os.ErrNotExist) {
		log.Debug(
			"failed to get path stat",
			slog.String("path", path),
			sl.Err(err),
		)
		return fmt.Errorf("%s: %w", op, err)
	}

	if err := os.MkdirAll(path, 0777); err != nil {
		log.Error(
			"failed to make dir",
			slog.String("dir", path),
			sl.Err(err),
		)
		return err
	}

	log.Debug(
		"made dir",
		slog.String("dir", c.path+"/"+ffmpeg.Dir(s)),
	)

	media, err := c.media.Media(ctx, *s.MediaID)
	if err != nil {
		log.Error(
			"failed to get media",
			slog.Int64("mediaID", *s.MediaID),
			sl.Err(err),
		)
		return fmt.Errorf("%s: %w", op, err)
	}

	log.Debug("got media", slog.Int64("mediaID", *s.MediaID))

	filePath, err := c.source.LoadSource(ctx, c.path+"/.cache", media)
	if err != nil {
		log.Error(
			"failed to load source file",
			slog.Int64("sourceID", *media.SourceID),
			sl.Err(err),
		)
		return fmt.Errorf("%s: %w", op, err)
	}

	log.Debug("loaded source", slog.Int64("sourceID", *media.SourceID))

	// TODO: get meta information

	// set the limit for bitrate (placeholder before bitrateSwitching)
	bitrate := maxBitrate
	// if cmp.meta.bitrate < bitrate {
	// 	bitrate = cmp.meta.bitrate
	// }
	// set the limit for sampling rate
	samplingRate := maxSamplingRate
	// if cmp.meta.sampling_rate < samplingRate {
	// 	samplingRate = cmp.meta.sampling_rate
	// }

	// TODO: temporary disabled start/stop cutting,
	// return it later

	// startString := strconv.FormatFloat(s.BeginCut.Seconds(), 'g', -1, 64)
	// stopString := strconv.FormatFloat(s.StopCut.Seconds(), 'g', -1, 64)
	durationString := strconv.FormatFloat(c.chunkLenght.Seconds(), 'g', -1, 64)

	cmd := exec.Command(
		"ffmpeg",       //						call converter
		"-hide_banner", //						hide banner
		"-y",           //						force rewriting file
		// "-ss", startString, //						start cut
		// "-to", stopString, //						stop cut
		"-i", filePath, //							input file
		"-c:a", "aac", //							choose codec
		"-b:a", strconv.Itoa(bitrate), //			choose bitrate (TODO: make different bitrate to enable bitrateSwitching)
		"-ac", strconv.Itoa(2), //					number of channels (1 - mono, 2 - stereo)
		"-ar", strconv.Itoa(samplingRate), // 		sampling frequency (usually 44100/48000)
		"-dash_segment_type", "mp4", //				container segments format
		"-use_template", "1", //					use template instead of enumerate (shorter output)
		"-use_timeline", "0", //					more information about timing for all segments
		"-init_seg_name", ffmpeg.InitFile(s), //	template for initialization segment
		"-media_seg_name", ffmpeg.ChunkFile(s), //	template for data segments
		"-seg_duration", durationString, //			duration of each segment
		"-f", "dash", //							choose dash format
		c.path+"/"+mpdFile, //						output file
	)

	log.Debug("prepared cmd", slog.String("cmd", cmd.String()))

	errorWriter := NewWriter()
	cmd.Stderr = errorWriter

	log.Debug("set stderr")

	if err := cmd.Run(); err != nil {
		log.Error(
			"failed to run command",
			slog.String("cmd", cmd.String()),
			slog.String("stderr", errorWriter.String()),
			sl.Err(err),
		)
		return fmt.Errorf("%s: %w", op, err)
	}

	log.Debug("ran cmd")

	time.AfterFunc(
		time.Until(*s.Start)+*s.StopCut-*s.BeginCut+waitBeforeDelete,
		func() { c.deleteDASHFiles(s) },
	)

	log.Debug(
		"set timer to delete content",
		slog.Int64("id", *s.ID),
	)

	return nil
}

// Delete segments, generated by ffmpeg
// for current composition
func (c *Content) deleteDASHFiles(s models.Segment) error {
	const op = "Content.deleteDASHFiles"

	log := c.log.With(
		slog.String("op", op),
	)

	path := c.path + "/" + ffmpeg.Dir(s)
	if err := os.RemoveAll(path); err != nil {
		log.Error("failed to delete dash files", slog.String("path", path), sl.Err(err))
		return err
	}

	log.Debug(
		"deleted content",
		slog.Int64("id", *s.ID),
		slog.String("path", c.path+"/"+ffmpeg.Dir(s)),
	)

	return nil
}

// deleteCache deletes all files in .cache
func (c *Content) deleteCache() error {
	const op = "Content.deleteCache"

	log := c.log.With(
		slog.String("op", op),
	)

	cacheDir := c.path + "/.cache"

	files, err := os.ReadDir(cacheDir)
	if err != nil {
		log.Error(
			"failed to get list of content dir",
			slog.String("dir", c.path),
			sl.Err(err),
		)
	}

	errAll := make([]error, 0)
	for _, file := range files {
		log.Debug("", slog.String("item", file.Name()))
		err = os.Remove(cacheDir + "/" + file.Name())
		if err != nil {
			log.Error(
				"failed to delete",
				slog.String("item", file.Name()),
				slog.String("cache dir", cacheDir),
				sl.Err(err),
			)
			errAll = append(errAll, err)
		}
	}
	if len(errAll) > 0 {
		return errors.Join(errAll...)
	}

	log.Debug("cleared cache")

	return nil
}

// deleteAll deletes all files from working directory
func (c *Content) deleteAll() error {
	const op = "Content.deleteAll"

	log := c.log.With(
		slog.String("op", op),
	)

	files, err := os.ReadDir(c.path)
	if err != nil {
		log.Error(
			"failed to get list of content dir",
			slog.String("dir", c.path),
			sl.Err(err),
		)
	}

	errAll := make([]error, 0)
	for _, file := range files {
		log.Debug("", slog.String("item", file.Name()))
		if file.Name() != ".cache" {
			err = os.RemoveAll(c.path + "/" + file.Name())
			if err != nil {
				log.Error(
					"failed to delete",
					slog.String("item", file.Name()),
					slog.String("dir", c.path),
					sl.Err(err),
				)
				errAll = append(errAll, err)
			}
		}
	}
	if len(errAll) > 0 {
		return errors.Join(errAll...)
	}

	log.Debug("deleted all dash files", slog.String("dir", c.path))

	if err := c.deleteCache(); err != nil {
		log.Error(
			"failed to delete cache",
			sl.Err(err),
		)
	}
	log.Debug("deleted cache")

	return nil
}
